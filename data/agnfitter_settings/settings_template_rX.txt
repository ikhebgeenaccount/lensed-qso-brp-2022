'''
AGNfitter setting file:
required:
CATALOG_settings
FILTERS_settings
MCMC_settings
OUTPUT_settings
For default use (test example with 2 redshifts and default filter set)
Change only the functions which state
***USER INPUT NEEDED***.
'''
import os
def CATALOG_settings():
    '''==================================
    ***USER INPUT NEEDED***
    Set the right values to be able to read your catalog's format.
    FITS option is not available yet.
    =================================='''
    cat = dict()
    ##GENERAL
    cat['path'] = {agnfitter_path}  #path to the AGNfitter code
    cat['filename'] = cat['path']+'data/{name}.txt'
    cat['filetype'] = 'ASCII' ## catalog file type: 'ASCII' or 'FITS'.
    cat['name'] = 0                 ## If ASCII: Column index (int) of source IDs
                                    ## If FITS : Column name (str). E.g. 'ID'
    cat['redshift'] = 1             ## If ASCII:  Column index(int) of redshift
                                     ## If FITS : Column name (str). E.g. z'
   ##FREQUENCIES/WAVELENGTHS
    ## if ASCII specify 'freq/wl_list', if FITS specify 'freq/wl_suffix'
    cat['freq/wl_list'] = np.arange(2,{length},3).tolist()  #138 147
                                        ## If ASCII: List of column indexes (int),
                                        ##           corresponding to freq/wl.
    #cat['freq/wl_suffix'] = '_wl'      ## If FITS: common ending to wavelength column names
    cat['use_central_wavelength'] = True # Option to use central wavelength if no wavelengths in table
    cat['freq/wl_format'] = 'wavelength' ## Gives your catalog *observed*
                                         ## 'frequency' or 'wavelength'?
    cat['freq/wl_unit'] = u.Angstrom #u. Angstrom u.micron     ## Astropy unit of freq or wavelength
    ##FLUXES
    ## if ASCII specify 'freq/wl_list', if FITS specify 'freq/wl_suffix'
    cat['flux_in_magAB'] = False # Option to calculate flux and flux_error from magnitude AB.
    cat['flux_unit'] = u.Jy * 1e-3            ## Astropy unit of *flux* (astropy-units)
    cat['flux_list'] = np.arange(3,{length + 1},3).tolist()      #139 148
                                        ## If ASCII: List of column indexes (int)
    #cat['flux_suffix'] = '_f'          ## If FITS: Common ending of all flux column names (str)
    cat['fluxerr_list'] = np.arange(4,{length + 2},3).tolist() #140 149
                                        ## If ASCII: List of column indexes (int)
    #cat['fluxerr_suffix'] = '_e'       ## If FITS: common ending to fluxerr column names (str)
    cat['err+10%flux_moreflex'] = False
    ##NON-DETECTIONS
    cat['ndflag_bool'] = False          ## Does you catalog has columns with flags 1(0) for
                                        ## detections (nondetections)?
    cat['ndflag_list'] = 'list'         ## If ASCII: List of column indexes (int)
                                        ## If FITS: List of column names (str)
    ## COSTUMIZED WORKING PATHS
    cat['workingpath'] = cat['path']  # Allows for a working path other than the AGNfitter code path.
                                      # Will include:
                                            # dictionary of models
                                            # SETTINGS_AGNFitter.py file
                                            # OUTPUT
                                      # Specially needed in order not to alter git original repository
                                      # and when using an external processor.
                                      # Default: cat['path'] (same as AGNfitter code path)

    cat['output_folder'] =  cat['workingpath'] +'OUTPUT/' #if no special OUTPUT folder, leave default
    return cat
def FILTERS_settings():
    '''==================================
    Set the photometric bands included in your catalog,
    in order to integrate the models over their response curves.
    =================================='''
    filters = dict()
    filters['dict_zarray'] = np.array([{redshift}]) # [0.058900, 0.042170] np.array([0.283, 1.58])  # Deprecated. The grid of redshifts needed to fit your catalog
    filters['path'] = 'models/FILTERS/'
    filters['filterset'] = 'example_46datapointa' ## 'filterset_default' (for the test case),
                                               ## for the user's case: customize, eg. filtersv1
{filters}
    filters['add_filters']= True # If 'True' please add them below in ADD FILTERS
    '''==================================
    ADD FILTERS (optional)
    =================================='''
    ADDfilters=dict()
    ADDfilters['names'] = {filternames}  ## (string/list of strings)User especified filter names.
                                ## If name has been previously used, an error message will appear.
    ADDfilters['filenames'] = {filterfilenames}  ## (string/list of strings) File names of the new filters.
                                ## File format: 2 columns of 1) freq/wavelength 2) Throughput.
                                ## Path assumed is the cat['path'] especified above.
                                ## Example: 'models/FILTERS/my_new_filter.txt'
    ADDfilters['freq/wl_format'] = ['wavelength'] * len(ADDfilters['names']) ## Info about the column 1 of your filter file.
                                                                             ## Options: 'wavelength' or 'frequency'.
    ADDfilters['freq/wl_unit'] =  [u.Angstrom]* len(ADDfilters['names']) ## (Astropy Unit) Info about the column 1
                                                                         ## of your filter file.
    ADDfilters['description'] = ['description_dummy']* len(ADDfilters['names']) ## (Str) Any description the user wants to give
                                                                                ##  to the filter to add.
    filters['add_filters_dict']= ADDfilters
    return filters
def MODELS_settings():
    '''==================================
    Work in progress
    =================================='''
    models = dict()
    models['path'] = 'models/'
    models['modelset'] = {modelset}
    models['GALAXY'] = {GALAXY}   ### Current options:
                                ### 'BC03' (Bruzual & Charlot 2003)
                                ### 'BC03_metal' (Bruzual & Charlot 2003), with metallicities
    models['STARBURST'] = {STARBURST} ### Current options:
                                ### 'DH02_CE01' (Dale & Helou 2002 + Chary & Elbaz 2001)
                                ### 'S17' (Schreiber et al. 2017 (submitted))
                                ### 'S17_newmodel'
                                ### 'S17_radio'
    models['BBB'] = {BBB} ### Current options:
                         ### 'R06' (Richards et al. 2006) ## Needs 2 manual changes in PARAMETERSPACE_AGNfitter.py
                         ### 'SN12' (Slone&Netzer 2012)
                         ### 'D12_S' (Done et al. 2012) for Schwarzschild BH, with x-ray predictions
                         ### 'D12_K' (Done et al. 2012) for Kerr BH, with x-ray predictions
    models['TORUS'] ={TORUS} ### Current options:
                           ### 'S04' (Silva et al. 2004)
                           ### 'NK0' (Nenkova et al. 2008)
                           ### 'NK0_2P' (Nenkova et al. 2008) with averaged SEDs for each inclination and openning angle
                           ### 'NK0_3P' (Nenkova et al. 2008) with averaged SEDs for each inclination, openning angle and optical depth
                           ### 'NK0_4P' (Nenkova et al. 2008)
                           ### 'SKIRTOR' (Stalevski et al. 2016)
                           ### 'SKIRTORC' with parameter values used in X-CIGALE
                           ### 'SKIRTORM' SKIRTOR model with averaged SEDs for each inclination
                           ### 'SKIRTORM_2P' SKIRTOR model with averaged SEDs for each inclination and openning angle
    models['XRAYS'] = {hasxray} ### If X-ray data is available and informative for the fit
    models['RADIO'] = {hasradio} ### If radio data is available and informative for the fit
    models['PRIOR_energy_balance'] = {PRIOR_energy_balance} ### Default:'Flexible'
                                          ### 'Flexible': Sets a lower limit to the dust emission luminosity ('starburst' model)
                                          ### as given by the observed attenuation in the stellar component SED.
                                          ### 'Restrictive': Favours a combination of parameters such that the luminosity of the cold dust
                                          ### and that attenuated in the stellar component are equal.
    models['PRIOR_AGNfraction'] = {PRIOR_AGNfraction}  ### Default: True
                                        ### True: - *IF* blue/UV bands (around 1500 Angstrom) are 10 times higher than expected by the galaxy luminosity function by Parsa, Dunlop et al. 2014.
                                        ###         this option rejects AGN-to-GAL ratios lower than 1 (log =0). It then applies a Gaussian prior probability with log ratio=2, with a sigma of 2.
                                        ###       - In this cases it also applies a Gaussian prior on the galaxy normalization, i.e. stellar mass (usually unconstrained in these cases) to
                                        ###         populate physically expected ranges for QSO hosts -> 10^9 - 10^11.
                                        ###       - *ELSE IF* blue/UV bands (around 1500 Angstrom) are below 10 times the expected value by Parsa, Dunlop et al. 2014.
                                        ###         this option gives preference to galaxy contribution in the optical UV, with Gaussian prior probability centered on AGN to GALAXY log ratios of -1.
                                        ###          and sigma 1, i.e. accretion disk is disfavoured at least the data strongly prefers it.
                                        ### False:- Non-informative prior
    models['PRIOR_midIR_UV'] = {PRIOR_midIR_UV}
    models['PRIOR_galaxy_only'] = {PRIOR_galaxy_only} ### Default:False
                                        ### True: sets all AGN contribution to 0.ß
    return models
def MCMC_settings():
    '''==================================
    Set your preferences for the MCMC sampling.
    =================================='''
    mc = dict()
    mc['Nwalkers'] = {nwalkers}  ## 100 number of walkers #100
    mc['Nburnsets']= {nburnsets}   ## number of burn-in sets
    mc['Nburn'] = {nburn} ## length of each burn-in sets
    mc['Nmcmc'] = {nmcmc}  ## length of each burn-in sets
    mc['iprint'] = {iprint} ## show progress in terminal in steps of this many samples
    return mc
def OUTPUT_settings():
    '''==================================
    Set your preferences for the production of OUTPUT files.
    =================================='''
    out = dict()
    out['plot_format'] = 'pdf'
    #CHAIN TRACES
    out['plot_tracesburn-in'] = {plot_tracesburn-in}
    out['plot_tracesmcmc'] = {plot_tracesmcmc}
    #BASIC OUTPUT
    out['Nsample'] = 1000 ## out['Nsample'] * out['Nthinning'] <= out['Nmcmc']
    out['Nthinning'] = 10 ## This describes thinning of the chain to sample
    out['writepar_meanwitherrors'] = True ##Write output values for all parameters in a file.
    out['plot_posteriortriangle'] = {plot_posteriortriangle} ##Plot triangle with all parameters' PDFs?
    #INTEGRATED LUMINOSITIES
    out['calc_intlum'] = True
    out['save_posterior_luminosities']= False
    out['save_posteriors']= True
    out['realizations2int'] = {realizations2int} #This process is very time consuming.
                                #Around 100-1000 is recomendend for computational reasons.
                                #If you want to plot posterior triangles of
                                #the integrated luminosities, should be > 1000.
    out['plot_posteriortrianglewithluminosities'] = {plot_posteriortrianglewithluminosities}  # requires out['calc_intlum']=True
    #INTEGRATION RANGES
    out['intlum_models'] = ['sb','bbb', 'bbbdered', 'gal', 'tor','agn_rad', 'tor+bbb','AGNfrac_IR', 'gal+bbb', 'AGNfrac_opt', 'bbb', 'tor','sb']  #leave 'sb' always as first element
    out['intlum_freqranges_unit'] = u.micron   #Astropy unit
    out['intlum_freqranges'] = np.array([[8.,1000.],[0.1,1.],[0.1,1.],[0.1,1.],[1.,30.],[0.1, 15000.], [0.1, 30], [8.,1000.],[0.4, 0.5], [0.4, 0.5], [1.2398e-4, 6.1992e-4], [6,6],   [1.,30.]])
    out['intlum_names'] = ['LIR(8-1000)','Lbb(0.1-1)', 'Lbbdered(0.1-1)', 'Lga(01-1)', 'Ltor(1-30)','Lagn_rad(0.1-15000)', 'LAGN(0.1-30)', 'AGNfrac(8-1000)', 'Lgal_bbb(0.4-0.5)', 'AGNfrac(0.4-0.5)', 'Lxr(2-10keV)',  'Ltor(6)', 'Lsb(1-30)']
    #SED PLOTTING
    out['realizations2plot'] = {realizations2plot}
    out['plot_residuals']= {plot_residuals}
    out['saveSEDresiduals'] = True
    out['plotSEDrealizations'] = {plotSEDrealizations}
    out['saveSEDrealizations'] = True
    return out